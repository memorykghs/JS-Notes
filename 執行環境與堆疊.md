# 執行環境與堆疊
在談到正題之前，我們要先來了解一下 JavaScript 這個語言的特性。你可能曾經聽說過 JavaScript 是一種**手稿語言**，到底什麼是手稿語言呢?

## 手稿語言 ( Scripting Language ) 與 編譯語言 ( Compiled language )

#### 手稿語言 ( Scripting Language )
又稱直譯語言 ( Interpreted language )，直譯語言多半以動態語言 ( dynamic language ) 為主，通常會具有以下幾個特點：

1. 在執行時期才會一行一行的將程式碼轉為機器看得懂的語言
2. 執行速度會比編譯式語言要慢一些 ( 畢竟執行當下才編譯嘛 )
3. 除錯的速度較編譯語言快 ( 先編譯在執行，當下就可以發現錯誤了 )

比較常見的手稿語言有：JavaScript、Python 等等。
<br/>

#### 編譯語言 ( Compiled language )
編譯語言在程式執行前會先透過編譯器 ( compiler ) ，像是 Eclipse 將程式碼編譯成計算機所看的懂的機器碼 ( machine language )，最後再執行。簡單來說會有以下特點：

1. 會事先定義型別及語法上的檢查，擁有較快的執行速度
2. 除錯速度較慢，要執行完畢才會知道會不會出錯

比較常見的編譯語言有：Java、C、C++ 等等。

#### 結論
通常直譯式語言必須依賴一個執行環境 ( execution context ) 才可以被執行。而語言可用的功能由這個執行環境提供，例如 JavaScript 只能使用瀏覽器提供的功能，不能獨立執行。

就像是你寫完了一個 .js 檔想要驗證他的功能有沒有達到你的預期，只能丟到瀏覽器上，打開 F12 開始 debug。

## 執行環境 Execution Context
JavaScript 是一種手稿語言，也就是說他在執行時期才會一行一行的被瀏覽器中的 JavaScript Engine 進行解析。接下來我們就會詳細的看一下在執行 js code 的時候，做了哪些事情。

我們有提到過手稿語言必須依賴一個執行環境才可以被執行，所以一段 JS code 只能在這3個環境下被執行：

1. **全域執行環境 ( Global Execution Context )**
JavaScript Engine 開始執行 js code 會創造一個全域環境，也就是我們熟知的 window。

2. **函式執行環境 ( Function Execution Context)**
當我們執行一個函式 function 時創造的環境。

3. **Eval**
把一串字串，當作指令來執行時的環境。( 這邊不會提到什麼是 Eval，可以先有印象就好! )
<br/>

#### 全域執行環境 ( Global Execution Context )
JavaScript Engine 開始執行 js code 會創造一個全域環境，同時他去設定一些內容，且一個瀏覽器頁面只有一個全域物件：

* `global object`
全域物件，會依照不同的執行環境有所不同，例如在瀏覽器上指的是 `window`，node 環境下則是 `global`。這個全域物件在瀏覽器被打開的時候，或是 Node.js 被啟動時，就建立了。
<br/>

* `this`
雖然 `global object` 會因為不同環境而有所不同，但 `this` 都會指向 `global object`。我們可以打開瀏覽器的 console 輸入 `window` 或是 `console.log(this)` 來驗證：

   ![ ](/images/execution-2.png)

   在這裡可以看到 `global` 是沒有被定義的。
<br/>

* 建立外部參考環境 ( reference environment )
* 建立參數 `var` 與函式 `function` 的記憶體空間
<br/>

#### 函式執行環境 ( Function Execution Context )
在 JavaScript 中，只有 function 會產生執行環境，到底什麼是執行環境呢?我們可以把它理解為一種單向結界的概念，外部無法取用到內部的參數，內部參數可以參考到外部參數。

像下面這個例子，就會產生兩個不同的執行環境，彼此間的參數無法互相被影響。

```javascript
function A(){
    var a = 'a';
}

function B(){
    var b = 'b';
}
```

function 產生的執行環境是可以疊加的，就是一個函示執行環境中可以在產生另一個函式一個執行環境，像下面這樣：

```javascript
function C(){
   var c = 'c';

   function D(){
      var d = 'd';
   }
}
```
由於 `function D` 是在 `function C` 的執行環境上又創造了一個執行環境，在這種情況下，`function C` 無法取得 `d` 這個參數的值，但 `function D` 可以取得參數 `c` 的值。我們多加個兩行來驗證一下：

```javascript
function C(){
   var c = 'c';
   console.log(d); // 新增的部分

   function D(){
      var d = 'd';
   }
}

C(); // 執行
```
應該會得到 `VM189:3 Uncaught ReferenceError: d is not defined` 的結果，因為參數 `d` 只存活在 `function D` 的執行環境中。
![ ](/images/execution-3.png)
<br/>

## 執行堆疊 Execution Stack
還記得上面提到全域執行環境在一個瀏覽器頁面是只有一個的，它在網頁被瀏覽器開啟或是後端 Node.js 被啟動時，就被建立了，另外會建立執行環境的是 function 被呼叫的時候。

然而 JavaScript 是一種同步的語言，也就是說著 JavaScript Engine 通常是單執行緒的，這代表其實在執行過程中一次只能做一件事。但剛剛提到 function 產生的執行環境是可以疊加的，所以還沒有做完的事情就會被丟到執行堆疊中，等手上的事情做完才會再輪到下一個。

```javascript
function E(){
   console.log('execute function E');

   function F(){
      console.log('execution function F');
   }

   F();
}

E();
```
以上面這個例子來說，事件堆疊大概會長的像這個樣子：

![ ](/images/execution-4.png)

那執行環境什麼時候會消失呢?

在這個 function 被執行完畢之後，執行環境就會消失了，執行環境消失，也就意味著這個事件離開執行堆疊，直到執行堆疊上只剩下全域環境，代表所有的程式碼已經被執行完畢。

![ ](/images/execution-5.png)

以上就是執行環境與堆疊大致的介紹，
下一章會提到在創造執行環境的時候，JavaScript背後到底幫你做了哪些事!

## 參考
* https://medium.com/@totoroLiu/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80-vs-%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80-5f34e6bae051
* https://medium.com/@yining1204/javascript-%E6%A0%B8%E5%BF%83%E7%AF%87-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-chap-8-%E8%AA%9E%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F-lexical-scope-e8e4d064c2c0
* https://medium.com/digital-dance/javascript%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83-execution-context-%E7%B0%A1%E4%BB%8B-672185ed6bf4 